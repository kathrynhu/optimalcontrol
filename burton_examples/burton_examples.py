# -*- coding: utf-8 -*-
"""Burton Examples.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1pzWJFY0av0u7v0emg_alM_YJ-QZe0sl6
"""

# Commented out IPython magic to ensure Python compatibility.
# %%capture
# import sys
# import os
# 
# if 'google.colab' in sys.modules:
#     !pip install idaes-pse --pre
#     !idaes get-extensions --to ./bin
#     os.environ['PATH'] += ':bin'

from pyomo.environ import *
from pyomo.dae import *
import matplotlib.pyplot as plt
import random
import math

N = 100
delta_tau = 1 / N

model = ConcreteModel()

# Time steps
model.T = RangeSet(0, N)

# DVs
model.t_f = Var(within=NonNegativeReals)
# test
#model.t_f.fix(1.0)

model.x = Var(model.T)
model.y = Var(model.T)
model.theta = Var(model.T)
model.u = Var(model.T, within=Reals, bounds=(-6, 6))

for t in model.T:
  model.x[t].set_value(10)
  model.y[t].set_value(10)
  model.theta[t].set_value(0.0)
  if t < N:
      model.u[t].set_value(0)

# Objective
model.objective = Objective(
    expr = model.t_f * sum((1 + 0.5 * model.u[t]**2) * delta_tau for t in model.T),
    sense=minimize
)

# Initial conditions
model.x[0].fix(0)
model.y[0].fix(0)
model.theta[0].fix(0)

# Dynamics constraints w/ Forward Euler
def x_dyn_rule(model, t):
    if t == 0:
        return Constraint.Skip
    return model.x[t] == model.x[t - 1] + model.t_f * cos(model.theta[t - 1]) * delta_tau

model.x_dyn = Constraint(model.T, rule=x_dyn_rule)

def y_dyn_rule(model, t):
    if t == 0:
        return Constraint.Skip
    return model.y[t] == model.y[t - 1] + model.t_f * sin(model.theta[t - 1]) * delta_tau

model.y_dyn = Constraint(model.T, rule=y_dyn_rule)

def theta_dyn_rule(model, t):
    if t == 0:
        return Constraint.Skip
    return model.theta[t] == model.theta[t - 1] + model.t_f * model.u[t - 1] * delta_tau

model.theta_dyn = Constraint(model.T, rule=theta_dyn_rule)

# Boundary conditions
model.terminal_constraint = Constraint(
    expr=model.x[N]**2 + model.y[N]**2 <= (0.1)**2
)

# Solve the model with the fixed t_f
solver = SolverFactory('ipopt')
solver.solve(model, tee=True)

# Plot values
time_steps = range(N + 1)
x_values = [model.x[t].value for t in time_steps]
y_values = [model.y[t].value for t in time_steps]
theta_values = [model.theta[t].value for t in time_steps]
u_values = [model.u[t].value for t in time_steps[:-1]]

# Trajectory
plt.figure(figsize=(10, 6))
plt.plot(x_values, y_values, label='(x, y)')
plt.xlabel('x')
plt.ylabel('y')
plt.title('Trajectory')
plt.legend()
plt.grid()

# Theta vs time
plt.figure(figsize=(10, 6))
plt.plot(time_steps, theta_values, label='Theta')
plt.xlabel('Time step')
plt.ylabel('Theta')
plt.title('Theta vs time')
plt.legend()
plt.grid()

# u vs time
plt.figure(figsize=(10, 6))
plt.plot(time_steps[:-1], u_values, label='u')
plt.xlabel('Time step')
plt.ylabel('u')
plt.title('u vs time')
plt.legend()
plt.grid()

plt.show()